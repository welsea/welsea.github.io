[{"title":"git bash下载速度慢","url":"/2019/02/02/git bash速度慢解决办法/","content":"本来家里速度就慢的要死...不走代理什么都clone不下来（。崩溃。</br>\n搜了一下，找到了解决办法。\n- 改一下，走代理就好了\n```\ngit config http.proxy http://127.0.1:1081\ngit config https.proxy https://127.0.1:1081\n```\n 这里的`1081`是v2ray的端口。在进程里找到pid然后cmd使用`netstat -ano`找端口。\n- 也可以直接改成全局的。用`--glabal`，不过如果是国内的库速度可能不会很好，推荐不用全局的。\n```\ngit config --global http.proxy http://127.0.1:1081\ngit config --global https.proxy https://127.0.1:1081\n```\n- 取消设定\n```\ngit config --global --unset http.proxy\ngit config --global --unset https.proxy\n```\n-查看config文件\n```\ngit config --global -e\n```\n\n\n\n","tags":["windows","git","git bash"]},{"title":"v2ray安装与配置","url":"/2019/02/02/v2ray安装与配置/","content":"\n参考[v2ray白话文教程](https://toutyrater.github.io/basic/vmess.html)\n\n1. 校准VPS时间\n    ```bash\n    //显示当前时间\n    $ date -R\n\n    //修改时间\n    $ date --set=\"2019-01-25 01:35\"\n    ```\n\n2. 下载脚本\n    ```bash\n    $ wget https://install.direct/go.sh\n    ```\n3. 安装脚本\n    ```bash\n    $ bash go.sh\n    ```\n4. 修改配置</br>\n - 获取UUID：[UUID自动生成](https://www.uuidgenerator.net/)\n    ```bash\n    $ vim /etc/v2ray/config.json\n    ```\n - 设置putty中vim的右键粘贴：\n    ```\n    :set paste\n    :set mouse=v\n    ```\n\n - 配置格式\n    ```json\n    {\n        \"inbounds\": [\n            {\n                \"port\": 16823, // 服务器监听端口\n                \"protocol\": \"vmess\",    // 主传入协议\n                \"settings\": {\n                    \"clients\": [\n                        {\n                            \"id\": \"b831381d-6324-4d53-ad4f-8cda48b30811\",  // 用户 ID，客户端与服务器必须相同\n                            \"alterId\": 64\n                        }\n                    ]\n                }\n            }\n        ],\n        \"outbounds\": [\n            {\n                \"protocol\": \"freedom\",  // 主传出协议\n                \"settings\": {}\n            }\n        ]\n    }\n    ```\n- 使用websocket的话：\n    ```json\n    {\n        \"inbounds\": [\n            {\n                \"port\": 16823,\n                \"protocol\": \"vmess\",\n                \"settings\": {\n                    \"clients\": [\n                    {\n                        \"id\": \"17c64783-6e8a-451c-8c22-be57fbfc7ab3\",\n                        \"alterId\": 64\n                    }\n                ]\n            },\n            \"streamSettings\": {\n                \"network\":\"ws\"\n            }\n        }\n    ],\n    \"outbounds\": [\n            {\n                \"protocol\": \"freedom\",\n                \"settings\": {}\n            }\n        ]\n    }\n    ```\n- 检测配置文件有没有错误，正确的是\n    ```bash\n    $ /usr/bin/v2ray/v2ray -test -config /etc/v2ray/config.json\n    V2Ray v3.15 (die Commanderin) 20180329\n    An unified platform for anti-censorship.\n    Configuration OK.\n    ```\n5. 开启v2ray\n    ```bash\n    $ systemctl start v2ray\n    ```\n6. 开启BBR\n    ```bash\n    echo \"net.core.default_qdisc=fq\" >> /etc/sysctl.conf\n    echo \"net.ipv4.tcp_congestion_control=bbr\" >> /etc/sysctl.conf\n    sysctl -p\n    ```\n    - 测试一下\n    ```bash\n    $ lsmod | grep bbr\n    tcp_bbr                20480  0\n    ```\n7. 完成。可能需要重启服务器之后才能使用。","tags":["windows","debian","vpn"]},{"title":"下载视频工具youtube-dl的安装与配置","url":"/2019/01/22/youtube-dl下载和配置/","content":"\n一个下载视频的软件，安装后直接在cmd使用。为了从BBC iplayer下视频发现的。\n记一下安装过程：\n1. 安装python，勾选添加到PATH和安装pip。安装后可能需要重启才能使用pip。\n2. 安装ffmpeg，直接从[官网](http://www.ffmpeg.org/)下载，然后解压将bin目录添加进PATH即可。\n3. 使用pip安装youtube-dl\n```shell\npip install youtube-dl\npip install --upgrade youtube-dl\n```\n4. 完成啦，使用指南\n```\nUsage: youtube-dl [OPTIONS] URL [URL...]\n\nOptions:\n  通用选项:\n    -h, --help                       打印帮助文档\n    --version                        打印版本信息\n    -U, --update                     更新到最新版(需要权限)\n    -i, --ignore-errors              遇到下载错误时跳过\n    --abort-on-error                 遇到下载错误时终止\n    --dump-user-agent                显示当前使用的浏览器(User-agent)\n    --list-extractors                列出所有的提取器(支持的网站)\n    --extractor-descriptions         同上\n    --force-generic-extractor        强制使用通用提取器下载\n    --default-search PREFIX          使用此前缀补充不完整的URLs，例如：\"ytsearch2 yt-dl\" 从youtube搜索并下载两个关于yt-dl视频. 使用\"auto\"youtube-dl就会猜一个，一般效果等价于\"ytsearch\"(\"auto_warning\"猜测时加入警告).我已知支持的PREFIX：ytsearch (youtube), ytsearchdate (youtube), yvsearch (yahoo videos), gvsearch (google videos) \n    --ignore-config                  不读取配置文件，当时用了全局配置文件/etc/youtube-dl.conf:不再读取 ~/.config/youtube-dl/config (%APPDATA%/youtube-dl/config.txt on Windows)\n    --config-location PATH           使用指定路径下的配置文件\n    --flat-playlist                  列出列表视频但不下载\n    --mark-watched                   标记看过此视频 (YouTube only)\n    --no-mark-watched                不标记看过此视频 (YouTube only)\n    --no-color                       打印到屏幕上的代码不带色\n\n  网络选项:\n    --proxy URL                      使用HTTP/HTTPS/SOCKS协议的代理.如：socks5://127.0.0.1:1080/.\n    --socket-timeout SECONDS         放弃连接前等待时间\n    --source-address IP              绑定的客户端IP地址\n    -4, --force-ipv4                 所有连接通过IPv4\n    -6, --force-ipv6                 所有连接通过IPv6\n\n  地理限制:\n    --geo-verification-proxy URL     使用此代理地址测试一些有地理限制的地址\n    --geo-bypass                     绕过地理限制通过伪装X-Forwarded-For HTTP头部的客户端ip (实验)\n    --no-geo-bypass                  不 绕过地理限制通过伪装X-Forwarded-For HTTP头部的客户端ip (实验)\n    --geo-bypass-country CODE        强制绕过地理限制通过提供准确的ISO 3166-2标准的国别代码(实验)\n\n  视频选择:\n    --playlist-start NUMBER          指定列表中开始下载的视频(默认为1)\n    --playlist-end NUMBER            指定列表中结束的视频(默认为last)\n    --playlist-items ITEM_SPEC       指定列表中要下载的视频项目编号.如：\"--playlist-items 1,2,5,8\"或\"--playlist-items 1-3,7,10-13\"\n    --match-title REGEX              下载标题匹配的视频(正则表达式或区分大小写的字符串)\n    --reject-title REGEX             跳过下载标题匹配的视频(正则表达式或区分大小写的字符串)\n    --max-downloads NUMBER           下载NUMBER个视频后停止\n    --min-filesize SIZE              不下载小于SIZE的视频(e.g. 50k or 44.6m)\n    --max-filesize SIZE              不下载大于SIZE的视频(e.g. 50k or 44.6m)\n    --date DATE                      仅下载上传日期在指定日期的视频\n    --datebefore DATE                仅下载上传日期在指定日期或之前的视频 (i.e. inclusive)\n    --dateafter DATE                 仅下载上传日期在指定日期或之后的视频 (i.e. inclusive)\n    --min-views COUNT                不下载观影数小于指定值的视频\n    --max-views COUNT                不下载观影数大于指定值的视频\n    --match-filter FILTER            通用视频过滤器. Specify any key (see help for -o for a list of available keys) to match if the key is present, !key to check if the key is not present, key > NUMBER (like \"comment_count > 12\", also works with >=, <, <=, !=, =) to compare against a number,key = ‘LITERAL‘ (like \"uploader = ‘Mike Smith‘\", also works with !=) to match against a string literal and & to require multiple matches. Values which are not known are excluded unless you put a question mark (?) after the operator. For example, to only match videos that have been liked more than 100 times and disliked less than 50 times (or the dislike functionality is not available at the given service), but who also have a description, use --match-filter \"like_count > 100 & dislike_count <? 50 & description\" .\n    --no-playlist                    当视频链接到一个视频和一个播放列表时，仅下载视频\n    --yes-playlist                   当视频链接到一个视频和一个播放列表时，下载视频和播放列表\n    --age-limit YEARS                下载合适上传年限的视频\n    --download-archive FILE          仅下载档案文件中未列出的影片，已下载的记录ID\n    --include-ads                    同时下载广告(实验)\n\n  下载选项:\n    -r, --limit-rate RATE            最大bps (e.g. 50K or 4.2M)\n    -R, --retries RETRIES            重试次数 (默认10), or \"infinite\".\n    --fragment-retries RETRIES       一个分段的最大重试次数(default is 10), or \"infinite\" (DASH, hlsnative and ISM)\n    --skip-unavailable-fragments     跳过不可用分段(DASH, hlsnative and ISM)\n    --abort-on-unavailable-fragment  放弃某个分段当不可获取时\n    --keep-fragments                 下载完成后，将下载的片段保存在磁盘上; 片段默认被删除\n    --buffer-size SIZE               设置缓冲区大小buffer (e.g. 1024 or 16K) (default is 1024)\n    --no-resize-buffer               不自动调整缓冲区大小.默认情况下自动调整\n    --playlist-reverse               以相反的顺序下载播放列表视频\n    --playlist-random                以随机的顺序下载播放列表视频\n    --xattr-set-filesize             Set file xattribute ytdl.filesize with expected file size (experimental)\n    --hls-prefer-native              使用本机默认HLS下载器而不是ffmpeg\n    --hls-prefer-ffmpeg              使用ffmpeg而不是本机HLS下载器\n    --hls-use-mpegts                 使用TS流容器来存放HLS视频,一些高级播放器允许在下载的同时播放视频\n    --external-downloader COMMAND    使用指定的第三方下载工具,当前支持：aria2c,avconv,axel,curl,ffmpeg,httpie,wget\n    --external-downloader-args ARGS  给第三方下载工具指定参数，如：--external-downloader aria2c --external-downloader-args -j8\n\n  文件系统选项:\n    -a, --batch-file FILE            文件中包含需要下载的URL\n    --id                             仅使用文件名中的视频ID\n    -o, --output TEMPLATE            Output filename template, see the \"OUTPUT TEMPLATE\" for all the info\n    --autonumber-start NUMBER        指定%(autonumber)s的起始值(默认为1)\n    --restrict-filenames             将文件名限制为ASCII字符，并避免文件名中的“＆”和空格\n    -w, --no-overwrites              不要覆盖文件\n    -c, --continue                   强制恢复部分下载的文件。 默认情况下，youtube-dl仅在可能时将恢复下载。\n    --no-continue                    不要恢复部分下载的文件(从头开始重新启动)\n    --no-part                        不使用.part文件 - 直接写入输出文件\n    --no-mtime                       不使用Last-modified header来设置文件最后修改时间\n    --write-description              将视频描述写入.description文件\n    --write-info-json                将视频元数据写入.info.json文件\n    --write-annotations              将视频注释写入.annotations.xml文件\n    --load-info-json FILE            包含视频信息的JSON文件(使用“--write-info-json”选项创建)\n    --cookies FILE                   文件从中读取Cookie(经测试，export cookies插件可以使用，但firebug导出的cookies导致错误)\n    --cache-dir DIR                  文件存储位置。youtube-dl需要永久保存一些下载的信息。默认为$XDG_CACHE_HOME/youtube-dl或/.cache/youtube-dl。目前，只有YouTube播放器文件（对于具有模糊签名的视频）进行缓存，但可能会发生变化。\n    --no-cache-dir                   不用缓存\n    --rm-cache-dir                   删除所有缓存文件\n\n  缩略图:\n    --write-thumbnail                把缩略图写入硬盘\n    --write-all-thumbnails           将所有缩略图写入磁盘\n    --list-thumbnails                列出所有可用的缩略图格式\n\n  详细/模拟选项:\n    -q, --quiet                      激活退出模式\n    --no-warnings                    忽略警告\n    -s, --simulate                   不下载不存储任何文件到硬盘，模拟下载模式\n    --skip-download                  不下载视频\n    -g, --get-url                    模拟下载获取视频直连\n    -e, --get-title                  模拟下载获取标题\n    --get-id                         模拟下载获取id\n    --get-thumbnail                  模拟下载获取缩略图URL\n    --get-description                模拟下载获取视频描述\n    --get-duration                   模拟下载获取视频长度\n    --get-filename                   模拟下载获取输出视频文件名\n    --get-format                     模拟下载获取输出视频格式\n    -j, --dump-json                  模拟下载获取JSON information.\n    -J, --dump-single-json           模拟下载获取每条命令行参数的JSON information.如果是个播放列表，就获取整个播放列表的JSON\n    --print-json                     下载的同时获取视频信息的JSON\n    --newline                        进度条在新行输出\n    --no-progress                    不打印进度条\n    --console-title                  在控制台标题栏显示进度\n    -v, --verbose                    打印各种调试信息\n    --dump-pages                     打印下载下来的使用base64编码的页面来调试问题（非常冗长）\n    --write-pages                    将下载的中间页以文件的形式写入当前目录中以调试问题\n    --print-traffic                  显示发送和读取HTTP流量\n    -C, --call-home                  联系youtube-dl服务器进行调试\n    --no-call-home                   不联系youtube-dl服务器进行调试\n\n  解决方法:\n    --encoding ENCODING              强制指定编码(实验)\n    --no-check-certificate           禁止HTTPS证书验证\n    --prefer-insecure                使用未加密的连接来检索有关视频的信息(目前仅支持YouTube)\n    --user-agent UA                  指定user agent\n    --referer URL                    指定自定义的referer,仅限视频来源于同一网站\n    --add-header FIELD:VALUE         指定一个自定义值的HTTP头文件,使用分号分割,可以多次使用此选项\n    --bidi-workaround                围绕缺少双向文本支持的终端工作。需要在PATH中有bidiv或fribidi可执行文件\n    --sleep-interval SECONDS         在每次下载之前休眠的秒数，或者每次下载之前的随机睡眠的范围的下限(最小可能的睡眠秒数)与-max-sleep-interval一起使用。\n    --max-sleep-interval SECONDS     每次下载前随机睡眠范围的上限(最大可能睡眠秒数)。只能与--min-sleep-interval一起使用。\n\n  视频格式选项:\n    -f, --format FORMAT              视频格式代码,查看\"FORMAT SELECTION\"获取所有信息\n    --all-formats                    获取所有视频格式\n    --prefer-free-formats            开源的视频格式优先，除非有特定的请求\n    -F, --list-formats               列出请求视频的所有可用格式\n    --youtube-skip-dash-manifest     不要下载关于YouTube视频的DASH清单和相关数据\n    --merge-output-format FORMAT     如果需要合并(例如bestvideo + bestaudio)，则输出到给定的容器格式。mkv，mp4，ogg，webm，flv之一。如果不需要合并，则忽略\n\n  字幕选项:\n    --write-sub                      下载字幕文件\n    --write-auto-sub                 下载自动生成的字幕文件 (YouTube only)\n    --all-subs                       下载所有可用的字幕\n    --list-subs                      列出所有字幕\n    --sub-format FORMAT              字幕格式,接受格式偏好,如：\"srt\" or \"ass/srt/best\"\n    --sub-lang LANGS                 要下载的字幕的语言(可选)用逗号分隔,请使用--list-subs表示可用的语言标签\n\n  验证选项:\n    -u, --username USERNAME          使用ID登录\n    -p, --password PASSWORD          账户密码,如果此选项未使用,youtube-dl将交互式地询问。\n    -2, --twofactor TWOFACTOR        双因素认证码\n    -n, --netrc                      使用.netrc认证数据\n    --video-password PASSWORD        视频密码(vimeo, smotri, youku)\n\n  Adobe Pass Options:\n    --ap-mso MSO                     Adobe Pass多系统运营商(电视提供商)标识符,使用--ap-list-mso列出可用的MSO\n    --ap-username USERNAME           MSO账号登录\n    --ap-password PASSWORD           账户密码,如果此选项未使用,youtube-dl将交互式地询问。\n    --ap-list-mso                    列出所有支持的MSO\n\n  后处理选项:\n    -x, --extract-audio              将视频文件转换为纯音频文件(需要ffmpeg或avconv和ffprobe或avprobe)\n    --audio-format FORMAT            指定音频格式: \"best\", \"aac\", \"flac\", \"mp3\", \"m4a\", \"opus\", \"vorbis\", or \"wav\"; \"best\" by default;-x存在时无效\n    --audio-quality QUALITY          指定ffmpeg/avconv音频质量,为VBR插入一个0(best)-9(worse)的值(默认5),或者指定比特率\n    --recode-video FORMAT            必要时将视频转码为其他格式(当前支持: mp4|flv|ogg|webm|mkv|avi)\n    --postprocessor-args ARGS        给后处理器提供这些参数\n    -k, --keep-video                 视频文件在后处理后保存在磁盘上; 该视频默认被删除\n    --no-post-overwrites             不要覆盖后处理文件; 默认情况下,后处理文件将被覆盖\n    --embed-subs                     在视频中嵌入字幕(仅适用于mp4,webm和mkv视频）\n    --embed-thumbnail                将缩略图嵌入音频作为封面艺术\n    --add-metadata                   将元数据写入视频文件\n    --metadata-from-title FORMAT     从视频标题中解析附加元数据，如歌曲标题/艺术家。格式语法和--output相似.也可以使用带有命名捕获组的正则表达式。解析的参数替换现有值。Example: --metadata-from-title \"%(artist)s - %(title)s\" matches a title like \"Coldplay - Paradise\". Example (regex): --metadata-from-title \"(?P<artist>.+?) - (?P<title>.+)\" \n    --xattrs                         将元数据写入视频文件的xattrs(使用dublin core 和 xdg标准)\n    --fixup POLICY                   自动更正文件的已知故障。never(不做警告), warn(只发出警告), detect_or_warn (默认;如果可以的话修复文件,否则警告)\n    --prefer-avconv                  后处理时相较ffmpeg偏向于avconv\n    --prefer-ffmpeg                  后处理优先使用ffmpeg\n    --ffmpeg-location PATH           ffmpeg/avconv程序位置;PATH为二进制所在文件夹或者目录.\n    --exec CMD                       在下载后对文件执行命令,类似于find -exec语法.示例：--exec‘adb push {} /sdcard/Music/ && rm {}‘\n    --convert-subs FORMAT            转换字幕格式(当前支持: srt|ass|vtt)\n```","tags":["windows","download","youtube-dl"]},{"title":"npm命令运行时卡住","url":"/2019/01/21/npm命令卡住/","content":"- 需要添加国内源，这里使用淘宝的\n1. 找到npmrc文件，windows路径参考：\n    ```\n    C:\\Users\\[User name]\\AppData\\Roaming\\npm\\node_modules\\npm\\npmrc\n    ```\n    如果没有这个路径，可以先执行\n    ```\n    npm i -g npm\n    ```\n2. 在npmrc文件中添加\n    ```\n    registry=https://registry.npm.taobao.org/\n    ELECTRON_MIRROR=http://npm.taobao.org/mirrors/electron/\n    ```\n这样就会快很多啦","tags":["windows","npm"]},{"title":"图片点击放大","url":"/2018/12/27/图片点击放大/","content":"\n点击放大，再点击缩小。\n\n- html\n```html\n<div class=\"content\">\n    <img src=\"pic.png\">\n</div>\n```\n- css\n```css\n/* 这里的图片大小自己设置 */\n.content img {\n    cursor: zoom-in;\n}\n.TempContainer {\n    position:fixed; \n    display: block; \n    top:0%; \n    left:0%; \n    height:100%; \n    width:100%; \n    z-index:99999999; \n    background: rgba(255, 255, 255,0.8); \n    overflow: auto; \n    display:-webkit-box; \n    -webkit-box-align:center; \n    -webkit-box-pack:center; \n    display:-moz-box; \n    -moz-box-align:center; \n    -moz-box-pack:center; \n    display:-o-box; \n    -o-box-align:center; \n    -o-box-pack:center; \n    display:-ms-box; \n    -ms-box-align:center; \n    -ms-box-pack:center; \n    display:box; \n    box-align:center; \n    box-pack:center;\n}\n.TempContainer img {\n    clear: both;  \n    display: block; \n    margin:auto; \n    cursor: zoom-out;\n}\n```\n- js\n```js\nvar ImgsTObj = $('.content img');\n    if(ImgsTObj){\n        $.each(ImgsTObj,function(){\n            $(this).click(function(){\n            var currImg = $(this);\n            // CoverLayer(0);\n            var TempContainer = $('<div class=\"TempContainer\"></div>');\n            with(TempContainer){\n                appendTo(\"body\");\n                    //css('top',currImg.offset().top);\n                html('<img border=0  src=\"' + currImg.attr('src') + '\">');\n                //不需要蒙层效果不用加\n                $('#bd').css('overflow','hidden')\n                // document.getElementById('bd').style.overflow=\"hidden\";\n            }\n            TempContainer.click(function(){\n                $(this).remove();\n                //不需要蒙层效果不用加\n                $('#bd').css('overflow','auto')\n                // document.getElementById('bd').style.overflow=\"auto\";\n                // CoverLayer(0);\n                });\n            });\n        });\n    }else{\n        return false;\n    }\n```","tags":["js"]},{"title":"输入时提示和自动补全","url":"/2018/12/24/输入时提示和自动补全/","content":"\n\n其实jQuery UI有autocomplete，但是和公司现在的项目不知道怎么就冲突了（。于是使用了最原始的js来实现。\n\n- html\n```html\n<div class=\"autocomplete\">\n    <input id=\"myInput\" autocomplete=\"off\" type=\"text\" name=\"area\" placeholder=\"Name\">\n</div>\n```\n- css\n```css\n#myInput{\n    line-height: 20px;\n    font-size: 14px;\n    box-shadow: 0px 0px 2px 0px rgba(170, 170, 170, 1);\n    font-family: Arial;\n    border: 1px solid rgba(255, 255, 255, 0);\n    padding: 10px 25px 10px 10px;\n    margin: 0 0 3% 0;\n    border-radius: 5px;\n    width: 70%;\n    color:#848484;\n}\n.autocomplete{\n    width: 40%;\n}\n.select-list{\n    display: flex;\n    justify-content: flex-start;\n}\n.autocomplete-items {\n    background-color: #fff;\n    padding: 3px;\n    position: absolute;\n    border: 1px solid rgba(255, 255, 255, 0);\n    box-shadow: 0px 0px 2px 0px rgba(170, 170, 170, 1);\n    color: #848484;\n    z-index: 999999;\n    /* position the autocomplete items to be the same width as the container: */\n\n}\n```\n- js\n```js\n  function autocomplete(inp, arr) {\n    /*the autocomplete function takes two arguments,\n    the text field element and an array of possible autocompleted values:*/\n    var currentFocus;\n    /*execute a function when someone writes in the text field:*/\n    inp.addEventListener(\"input\", function(e) {\n        var a, b, i, val = this.value;\n        /*close any already open lists of autocompleted values*/\n        closeAllLists();\n        if (!val) { return false;}\n        currentFocus = -1;\n        /*create a DIV element that will contain the items (values):*/\n        a = document.createElement(\"DIV\");\n        a.setAttribute(\"id\", this.id + \"autocomplete-list\");\n        a.setAttribute(\"class\", \"autocomplete-items\");\n        /*append the DIV element as a child of the autocomplete container:*/\n        this.parentNode.appendChild(a);\n        /*for each item in the array...*/\n        for (i = 0; i < arr.length; i++) {\n          /*check if the item starts with the same letters as the text field value:*/\n          if (arr[i].substr(0, val.length).toUpperCase() == val.toUpperCase()) {\n            /*create a DIV element for each matching element:*/\n            b = document.createElement(\"DIV\");\n            /*make the matching letters bold:*/\n            b.innerHTML = \"<strong>\" + arr[i].substr(0, val.length) + \"</strong>\";\n            b.innerHTML += arr[i].substr(val.length);\n            /*insert a input field that will hold the current array item's value:*/\n            b.innerHTML += \"<input type='hidden' value='\" + arr[i] + \"'>\";\n            /*execute a function when someone clicks on the item value (DIV element):*/\n                b.addEventListener(\"click\", function(e) {\n                /*insert the value for the autocomplete text field:*/\n                inp.value = this.getElementsByTagName(\"input\")[0].value;\n                /*close the list of autocompleted values,\n                (or any other open lists of autocompleted values:*/\n                closeAllLists();\n            });\n            a.appendChild(b);\n          }\n        }\n    });\n    /*execute a function presses a key on the keyboard:*/\n    inp.addEventListener(\"keydown\", function(e) {\n        var x = document.getElementById(this.id + \"autocomplete-list\");\n        if (x) x = x.getElementsByTagName(\"div\");\n        if (e.keyCode == 40) {\n          /*If the arrow DOWN key is pressed,\n          increase the currentFocus variable:*/\n          currentFocus++;\n          /*and and make the current item more visible:*/\n          addActive(x);\n        } else if (e.keyCode == 38) { //up\n          /*If the arrow UP key is pressed,\n          decrease the currentFocus variable:*/\n          currentFocus--;\n          /*and and make the current item more visible:*/\n          addActive(x);\n        } else if (e.keyCode == 13) {\n          /*If the ENTER key is pressed, prevent the form from being submitted,*/\n          e.preventDefault();\n          if (currentFocus > -1) {\n            /*and simulate a click on the \"active\" item:*/\n            if (x) x[currentFocus].click();\n          }\n        }\n    });\n    function addActive(x) {\n      /*a function to classify an item as \"active\":*/\n      if (!x) return false;\n      /*start by removing the \"active\" class on all items:*/\n      removeActive(x);\n      if (currentFocus >= x.length) currentFocus = 0;\n      if (currentFocus < 0) currentFocus = (x.length - 1);\n      /*add class \"autocomplete-active\":*/\n      x[currentFocus].classList.add(\"autocomplete-active\");\n    }\n    function removeActive(x) {\n      /*a function to remove the \"active\" class from all autocomplete items:*/\n      for (var i = 0; i < x.length; i++) {\n        x[i].classList.remove(\"autocomplete-active\");\n      }\n    }\n    function closeAllLists(elmnt) {\n      /*close all autocomplete lists in the document,\n      except the one passed as an argument:*/\n      var x = document.getElementsByClassName(\"autocomplete-items\");\n      for (var i = 0; i < x.length; i++) {\n        if (elmnt != x[i] && elmnt != inp) {\n        x[i].parentNode.removeChild(x[i]);\n      }\n    }\n  }\n  /*execute a function when someone clicks in the document:*/\n  document.addEventListener(\"click\", function (e) {\n      closeAllLists(e.target);\n  });\n  }\n\n  var names=['Anna','Bob','Cavin','Parcy','Mark','Leia','David','Martin','Ryan','Anakin','Luke','Sirius','James'];\n  autocomplete(document.getElementById(\"myInput\"), names);\n  ```","tags":["js"]},{"title":"select的点击事件","url":"/2018/12/22/select的点击事件/","content":"\n## 下拉选择\\<select\\>的点击事件\n\nhtml为\n```html\n<select id=\"sort-by\">\n    <option>Sort by</option>\n    <option value=\"Hotest\">Hotest</option>\n    <option value=\"Newest\">Newest</option>\n    <option value=\"Rarest\">Rarest</option>\n</select>\n```\n如果给option绑定click事件是没有用的，给select绑定click事件则会在选中option之前就触发。<br/>\n需要给select绑定onchange事件。代码如下：\n```js\n$('#sort-by').change(function(){\n    console.log($(this).val())\n})\n```\n这个时候console.log打印出来的就是选中的option的值啦。\n","tags":["jQuery","js"]},{"title":"ios(safari)修改input和select默认样式","url":"/2018/12/22/ios修改input和select默认样式/","content":"## 标题都不想写（\n```css\ninput{\n    -webkit-appearance: none;\n}\nselect{\n    -webkit-appearance: none;\n}\n```\n但是因为这样就没有小三角了，于是在背景加一个小三角图片\n```css\nselect{\n    -webkit-appearance: none；\n    background: url('../img/select_down.png') no-repeat right;\n    background-size: 15px;\n    background-position-x: 96%;\n}\n\n```","tags":["css"]},{"title":"url传值和获取url中的值","url":"/2018/12/08/url传值和获取url中的值/","content":"# 获取URL里的值。\n- 例如URL为： \n    `http://local.tc.com/index.php?s=/question/index/detail/id/1 `\n\n    <br/>\n    可以使用`{$_GET.id}`来获取值为1的id。\n\n- php代码如`{$vo.id}`在jQuery中不适用，应该改为`${jQuery的数组.id}`，例如\n    ```js\n    $.ajax({\n        dataType: \"json\",\n        url: \"{:U('Question/Index/detail')}\" + '&id=' + id + '&p=' + p,\n        type: \"get\",\n        success: function (data) {\n            console.log(data);\n            var list = data.data.answer_list;\n            for (var i = list.length - 1; i >= 0; i--) {\n                var html = '';\n                for (var j = list[i].comment_lists.length - 1; j >= 0; j--) {\n                    let cert = '';\n                    if (list[i].user.cert_info.title) {\n                        cert = `<div class=\"icon cert\"></div>\n                        <span id=\"cert\">${list[i].user.cert_info.title}</span>`\n                    };\n                    ......\n                }\n            }\n        }\n    });\n    ```\n\n# 页面跳转时传值\n- 使用`<a href=\"...\">`跳转页面时传值。\n    ```html\n    <a href=\"{:U('Question/Index/add',array('draft_id'=>$vo['id']))}\">...</a>\n    ```\n","tags":["jQuery","php"]},{"title":"jQuery遍历","url":"/2018/12/08/jQuery遍历/","content":"- 如，点击button展开相应的div:\n    ```html\n    <button class=\"close\" > close</button> \n    <div class\"display hidden\"> Show <div>\n\n    <button class=\"close\" > close</button> \n    <div class\"display hidden\"> Show <div>\n\n    <button class=\"close\" > close</button> \n    <div class\"display hidden\"> Show <div>\n\n    ```\n\n    有三个类名一样的组合，这时添加点击事件等会混淆，此时可以添加`data-id`\n    ```html\n    <button class=\"close\" data-id=\"1\" > close</button> \n    <div class\"display hidden\" data-id=\"1\"> Show <div>\n\n    <button class=\"close\" data-id=\"2\" > close</button> \n    <div class\"display hidden\" data-id=\"2\"> Show <div>\n\n    <button class=\"close\" data-id=\"3\"> close</button> \n    <div class\"display hidden\" data-id=\"3\"> Show <div>\n\n    ```\n    遍历的时候就是，当data-id相同才会触发事件\n    ```js\n    $('.close').click(function(){\n        let id=$(this).data('id');\n        $('display').each(function(index,element){\n            if(($(element).data('id'))===id){\n                $(element).toggleClass('hidden');\n            }\n        })\n    })\n    ```\n- 有在初始页面渲染后又加入的标签，比如f7的popup和无限滚动等，是在触发某一事件之后再生成的元素，此时如果对其添加事件，应该用.on()\n    - 比如\n    ```js\n    $(document).on('click','.test',function(){...})\n    ```\n    - 或者\n    ```js\n    $('.test').on(......)\n    ```","tags":["jQuery"]},{"title":"点击加载更多","url":"/2018/12/04/点击加载更多/","content":"# ajax一次全部加载，分批显示，点击加载更多\n\n- 我需要的点击More之后加载12个。\n- 其实就是加了一层page，比如原来的html为\n    ```html\n    <div class=\"list\">\n    </div>\n    ```\n    现在就是\n    ```html\n    <div class=\"list\">\n        <div class=\"page\">\n        </div>\n    </div>\n    ```\n1. 在调取全部数据的时候，在append之前加一个判断，先创建（总数/12）个page\n    ```js\n    //遍历的变量为i\n    if(i/12===0){\n        let page='<div class=\"page-\"'+parseInt(i/12)+'\"></div>;\n        $('.list').append(page);\n    }\n    ```\n2. 然后将各个元素append进他应该在的page\n    ```js\n    let item='<span class=\"item-'+i+'\"></span>';\n    $('.page-'+parseInt( i / 12)).append(item);\n    ```\n3. 之后在除最后一个page之外的page都加上more按钮\n    ```js\n    for (let n = 0; n < $('.list').children('.page').length - 1; n++) {\n        let more = '<button id=\"more-' + n +'\" class=\"more-btn button\">More</button>';\n        $('.list').children('.page-' + n).append(more);\n    }\n    ```\n4. 默认只显示第一个page\n    ```js\n    for (let n = 1; n < $('.list').children('.page').length; n++) {\n        $('.list').children('.page-' + n).addClass('hidden');\n    }\n    \n    ```\n5. 点击more按钮之后加载下一页。\n    ```js\n    $('.more').click(function(){\n        let num = $(this).attr('id').split('-');\n        let n = parseInt(num[1]) + 1;\n        let id = 'page-' + n;\n        //如果这个more按钮的父元素（也就是他的page）的下一个兄弟节点（就是下一个page）的id和n相等，则移除这个more按钮和下一个page的hidden类。\n        if ($(this).parent().attr('id') === id) {\n            $(this).parent().next().removeClass('hidden');\n            $(this).remove();\n        } else {\n            console.log('error')；\n        }\n    });\n    ```\n\n### 写在项目中的代码\n- html\n```html\n<div class=\"country-list\">\n</div>\n```\n- jquery\n```js\n $.ajax({\n    type: 'post',\n    url: url, \n    dataType: 'json', \n    data: {},\n    success: function (data) {\n        var list = [];\n        $.each(data, function (i, item) { //循环得出洲名\n            list.push(item.chau);\n            var aa = '<div id=\"' + item.s_name + '\">' +\n                '<div class=\"chau\">' + item.chau +\n                '<div class=\"icon open\"></div></div>' +\n                '<div class=\"list hidden\" id=\"item' + i +\n                '\">';\n            $(\".country-list\").append(aa);\n            $.each(item['countries'], function (j, item2) { //循环得出国家\n                if (j % 12 === 0) {\n                    let page = '<div class=\"my-page\" id=\"' + item.s_name +\n                        '-page-' + (j / 12) +\n                        '\"></div>';\n                    $('#item' + i).append(page);\n                }\n                //国家\n                let bb = '<span class=\"item not-selected\" id=\"' + item2[\n                        \"name\"] +\n                    '\" data-id=' + j + '>' + item2[\"name\"] +\n                    '</span>';\n                $('#item' + i).children('#' + item.s_name + '-page-' + parseInt(\n                    j / 12)).append(bb);\n            });\n            //加入more按钮，第一个和最后一个page不加。\n            for (let n = 0; n < $('#item' + i).children('.my-page').length - 1; n++) {\n                let more = '<div class=\"more\"><a id=\"' + item.s_name + '-more-' + n +\n                    '\" class=\"more-btn button\">More</a></div>';\n                $('#item' + i).children('#' + item.s_name + '-page-' + n).append(more);\n            }\n            //默认只显示第一个page\n            for (let n = 1; n < $('#item' + i).children('.my-page').length; n++) {\n                $('#item' + i).children('#' + item.s_name + '-page-' + n).addClass(\n                    'hidden')\n            }\n        });\n        //country\n        $('.item').click(function () {\n            $(this).each(function (index, element) {\n                $(element).toggleClass('selected');\n            });\n        });\n        //展开城市列表\n        $('.chau').click(function () {\n            $(this).each(function (index, element) {\n                $(element).children('.icon').toggleClass('turn');\n                $(element).siblings('.list').toggleClass('hidden');\n                $(element).siblings('.all').toggleClass('hidden');\n            });\n        });\n        //点击加载更多\n        $('.more').click(function () {\n            let num = $(this).children('.more-btn').attr('id').split('-');\n            let num2 = parseInt(num[2]) + 1;\n            let id = num[0] + '-page-' + num2;\n            if ($(this).parent().next().attr('id') === id) {\n                $(this).parent().next().removeClass('hidden');\n                $(this).remove();\n            } else {\n                console.log('error')\n            }\n        });\n    },\n    error: function (errorMsg) {\n        //请求失败时执行该函数\n        alert(\"发生错误!\");\n    }\n});\n ```","tags":["jQuery","ajax"]},{"title":"使用Google Maps JavaScript API","url":"/2018/11/26/使用GMapAPI/","content":"\n官方文档链接：https://developers.google.com/maps/documentation/javascript/tutorial\n- 首先引入\n```html\n<script async defer src=\"https://maps.googleapis.com/maps/api/js?key=Your-Key&callback=initMap\"></script>\n```\n其中的`key=your-key`需要去申请。\n\n- 在html中引入\n```html\n<!--搜索地点-->\n<div>  \n    <input class=\"search\">  \n    <button class=\"search_btn\">Search</button>  \n</div>  \n<!--地图-->  \n<div id=\"map-canvas\" style=\"width:100%;height:380px;\"></div>  \n<div class=\"content\">  \n        <div>  \n            <a class=\"icon locate\" id=\"detect-btn\" title=\"click to detect your location\"></a>  \n            <span id=\"now\">Drag the mark to select a location</span>  \n        </div>  \n    </div>  \n</div>  \n```\n```js\n function initMap() {  \n    var map = new google.maps.Map(document.getElementById(\"map-canvas\"), {  \n        center: new google.maps.LatLng(40.731, -73.997), \n        //如果定位失败后，地图默认的中心位置 \n        zoom: 3, //地图比例，越大越详细  \n        fullscreenControl: false,  //关闭全屏按钮\n        zoomControl: true,  //开启放大缩小比例按钮  \n        streetViewControl: false,  //关闭街景模式  \n        mapTypeId: google.maps.MapTypeId.ROADMAP  \n    });  \n    // 建立可以拖拽选择位置的小红点   \n    var marker = new google.maps.Marker({  \n        position: map.getCenter(),  \n        draggable: true,  \n        map: map  \n    });  \n    // 小红点的位置，设置可移动，添加事件获取小红点当前的经纬度    \n    google.maps.event.addListener(map, \"idle\", function () {  \n        marker.setPosition(map.getCenter());  \n        document.getElementById(\"LatLng\").value = map.getCenter().lat().toFixed(6) + \",\" + map.getCenter().lng().toFixed(6);  \n    });  \n    google.maps.event.addListener(marker, \"dragend\", function (mapEvent) {  \n        map.panTo(mapEvent.latLng);  \n    });  \n    // initialize geolocation  \n    //开启自动定位 \n    if (navigator.geolocation) {  \n        navigator.geolocation.getCurrentPosition(function (position) {  \n          map.setCenter(new google.maps.LatLng(position.coords.latitude, position.coords.longitude));  \n        }, function () {  \n          document.getElementById('now').innerHTML =  \n            \"Sorry, geolocation API failed to detect your location.Please drag the mark to select your location.\";  \n        });  \n      }  \n    //geocoder是解析经纬度的，用来输出小红点的位置。  \n    //geocoder2是用来解析输入框中输入的位置，用来挪动小红点的位置。\n    //其实感觉一个就可以，但是文档里说location和address一次只能一个。\n    var geocoder = new google.maps.Geocoder;  \n    var geocoder2= new google.maps.Geocoder;  \n    var infowindow = new google.maps.InfoWindow;  \n    document.getElementById('select').addEventListener('click', function () {  \n        geocodeLatLng(geocoder, map, infowindow);  \n    });  \n    document.getElementById('search_btn').addEventListener('click',function(){  \n        gecodeAddress(geocoder2,map);  \n    })  \n}  \n// initialize geocoder  \n//根据小红点的经纬度来解析地理位置  \nfunction geocodeLatLng(geocoder, map, infowindow) {  \n    var input = document.getElementById('LatLng').value;  \n    var latlngStr = input.split(',', 2);  \n    var latlng = {  \n        lat: parseFloat(latlngStr[0]),  \n        lng: parseFloat(latlngStr[1])  \n    };  \n    geocoder.geocode({  \n        'location': latlng  \n    },   \n    function (results, status) {  \n        if (status === 'OK') {  \n            if (results[0]) {  \n                map.setZoom(4);  \n                //得到的数据格式可以参考：https://maps.google.com/maps/api/geocode/json?latlng=1.3437449,103.7540048&key=AIzaSyC1wF4wAiScz7nIbn9Kek698GRKFzyNeY8  \n               //根据需要获取地点，此处获取的是国家。 \n                var length = results[0].address_components.length;  \n                for (var j = 0; j < length; j++) {  \n                    if ((results[0].address_components[j].types[0] === 'country') &&(results[0].address_components[j].types[1] === 'political')) {  \n                        var city = results[0].address_components[j].long_name;  \n                        document.getElementById('now').innerHTML = \"Your location:\" + city;  \n                    }  \n                }  \n            } else {  \n                window.alert('Please try again.');  \n            }  \n        } else {  \n            window.alert('Geocoder failed due to: ' + status);  \n        }  \n    });  \n}  \n//获取搜索框输入内容，解析地理位置  \nfunction gecodeAddress(geocoder2,map){  \n    let address=document.getElementById('search_ipt').value;  \n    geocoder2.geocode({  \n        'address':address  \n    },  \n    function(results,status){  \n        if (status === 'OK') {  \n            if (results[0]) {  \n                map.setZoom(4);  \n                //挪动地图中心\n                map.setCenter(results[0].geometry.location);  \n                var length = results[0].address_components.length;  \n                //获取位置，同经纬度    \n                for (var j = 0; j < length; j++) {  \n                    if ((results[0].address_components[j].types[0] === 'country') &&(results[0].address_components[j].types[1] === 'political')) {  \n                        var city = results[0].address_components[j].long_name;  \n                        document.getElementById('now').innerHTML = \"Your location:\" + city;  \n                    }  \n                }  \n            } else {  \n                window.alert('Please try again.');  \n            }  \n        } else {  \n            window.alert('Geocoder failed due to: ' + status);  \n        }  \n    })  \n} \n\n```","tags":["js","GMap"]},{"title":"横向滚动","url":"/2018/11/15/横向滚动/","content":"# 横向滚动\n- css：\n```css\n.scroll-list{\n    overflow-x: scroll;\n    white-space: nowrap;\n    overflow-y: hidden;\n}\n.list-item{\n    display:inline-block;\n    width:20%;\n}\n\n```\n- html\n```html\n<div class=\"scroll-list\">\n    <div class=\"list-item\">\n        test\n    </div>\n</div>\n```","tags":["css","html"]}]